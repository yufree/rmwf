---
title: "PMDDA Meta-Workflow"
author: "Miao Yu"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,cache = T,message=T,warning=F)
library(rmwf)
sessionInfo()
```

# Demo data

Five SRM 1950 samples and six matrix blank samples were used as demo data

```{r download}
# Download demo data from figshare
library(rfigshare)
dir.create(file.path('data'), showWarnings = FALSE)
setwd(file.path('data'))
# NIST1950 postive data
dir.create(file.path('NIST1950'), showWarnings = FALSE)
setwd(file.path('NIST1950'))
article_id <- 13252196
details <- fs_details(article_id)
name <- sapply(details$files,function(x) x$name)
url <- sapply(details$files,function(x) x$download_url)
download.file(url, name)
setwd('..')
# matrix positive data
dir.create(file.path('Matrix'), showWarnings = FALSE)
setwd(file.path('Matrix'))
article_id <- 13252244
details <- fs_details(article_id)
name <- sapply(details$files,function(x) x$name)
url <- sapply(details$files,function(x) x$download_url)
download.file(url, name)
setwd('..')
path <- getwd()
files <- list.files(path,pattern = '*.mzML',recursive = T,full.names = T)
# DDA positive data
setwd('..')
dir.create(file.path('DDA'), showWarnings = FALSE)
setwd(file.path('DDA'))
article_id <- 13252394
details <- fs_details(article_id)
name <- sapply(details$files,function(x) x$name)
url <- sapply(details$files,function(x) x$download_url)
download.file(url, name)
path <- getwd()
ddafile <- list.files(path,pattern = '*.mzML',recursive = T,full.names = T)
# matrix DDA positive data
setwd('..')
dir.create(file.path('DDAMatrix'), showWarnings = FALSE)
setwd(file.path('DDAMatrix'))
article_id <- 13252631
details <- fs_details(article_id)
name <- sapply(details$files,function(x) x$name)
url <- sapply(details$files,function(x) x$download_url)
download.file(url, name)
path <- getwd()
ddafile <- list.files(path,pattern = '*.mzML',recursive = T,full.names = T)
# PMDDA positive data
setwd('..')
dir.create(file.path('PMDDA'), showWarnings = FALSE)
setwd(file.path('PMDDA'))
article_id <- 13253942
details <- fs_details(article_id)
name <- sapply(details$files,function(x) x$name)
url <- sapply(details$files,function(x) x$download_url)
download.file(url, name)
path <- getwd()
pmddafile <- list.files(path,pattern = '*.mzXML',recursive = T,full.names = T)
```

The data could be subset by msconvert to avoid peaks with low quality(co-elution and column washing phase). You need to install docker and pull the docker image from msconvert.

```{bash eval=F}
docker pull chambm/pwiz-skyline-i-agree-to-the-vendor-licenses
for f in $(basename path/*.mzML)
do
  docker run -it --rm -e WINEDEBUG=-all -v path/:/data chambm/pwiz-skyline-i-agree-to-the-vendor-licenses wine msconvert /data/$f --filter "scanTime [60,1080]"
done
```

# Optimization of XCMS

This chunk should run first to generate XCMS parameters. We suggest a computer with large memory to run this chunk for IPO package.

## IPO

```{r IPOpos,eval=FALSE}
library(IPO)
library(xcms)
peakpickingParameters <- getDefaultXcmsSetStartingParams('centWave')
# Uncomment this line to use your own data(suggested 3-5 pooled QC samples)
# path <- 'path/to/your/files'
# change to 5 for obitrap
peakpickingParameters$ppm <- 10
resultPeakpicking <- 
  optimizeXcmsSet(files = files[c(7,9,10)], 
                  params = peakpickingParameters,
                  plot = F,
                  subdir = NULL)

optimizedXcmsSetObject <- resultPeakpicking$best_settings$xset
retcorGroupParameters <- getDefaultRetGroupStartingParams()
retcorGroupParameters$minfrac <- 1
resultRetcorGroup <-
  optimizeRetGroup(xset = optimizedXcmsSetObject, 
                   params = retcorGroupParameters, 
                   plot = F,
                   subdir = NULL)
para <- c(resultPeakpicking$best_settings$parameters, 
          resultRetcorGroup$best_settings)
save(para,file = 'para.RData')
```

## Wrap function for peak picking

This chunk could be run after you have `para.RData` from last chunk.

```{r eval=FALSE}
library(xcms)
# here we use pre-optimized IPO parameters
data('para')
# Or you could load your own set from last chunk
load('para.RData')
getrtmz <- function(path,index = NULL){
  files <- list.files(path,pattern = ".CDF|.mzXML|.mzML",full.names = T,recursive = T)
  if(!is.null(index)){
    files<- files[index]
    }
  group <- xcms:::phenoDataFromPaths(files)
  if(NCOL(group)==1){
      sample_group <- group$class
  }else{
      cols <- colnames(group)
      sample_group <-  do.call(paste,c(group[cols],sep='_'))
  }
  sample_name=sub(basename(files),pattern = ".CDF|.mzXML|.mzML",replacement = '')
  pd <- cbind.data.frame(sample_name, sample_group)
  
  raw_data <- readMSData(files = files, pdata = new("NAnnotatedDataFrame", pd),
                       mode = "onDisk")
  # remove co-elution and column wash phase
  # filter_data <- filterRt(raw_data,rt = c(100,900))
  cwp <- CentWaveParam(peakwidth = c(para$min_peakwidth,para$max_peakwidth), 
                       ppm             = para$ppm,
                       noise           = para$noise,
                       snthresh        = para$snthresh,
                       mzdiff          = para$mzdiff,
                       prefilter       = c(para$prefilter,para$value_of_prefilter),
                       mzCenterFun     = para$mzCenterFun,
                       integrate       = para$integrate,
                       fitgauss        = para$fitgauss,
                       verboseColumns  = para$verbose.columns)
  owp <- ObiwarpParam(binSize        = para$profStep,
                      centerSample   = para$center,
                      response       = para$response,
                      distFun        = para$distFunc,
                      gapInit        = para$gapInit,
                      gapExtend      = para$gapExtend,
                      factorDiag     = para$factorDiag,
                      factorGap      = para$factorGap,
                      localAlignment = ifelse(para$localAlignment==0,F,T))
  pdp <- PeakDensityParam(sampleGroups = pd$sample_group,
                        bw      = para$bw,
                        minFraction = para$minfrac,
                        minSamples = para$minsamp,
                        maxFeatures = para$max,
                        binSize = para$mzwid)

  xdata <- findChromPeaks(raw_data, param = cwp)
  # xdata <- findChromPeaks(filter_data, param = cwp)
  xdata <- adjustRtime(xdata, param = owp)
  xdata <- groupChromPeaks(xdata, param = pdp)
  xdata <- fillChromPeaks(xdata)
  return(xdata)
}
```

# Peaks list

This chunk is used to generate peaks list and related csv, xcmsset object, xcmsEIC object for further analysis.

```{r eval=F}
# use your own data
# path <- 'path/to/your/file'
srm <- getrtmz(path)
# back up the xcmsset object, xcmsEIC object and peak list
mzrt <- enviGCMS::getmzrt(srm, name = 'srm', eic = T)
```

# Peaks filtering

Peaks list could be processed by experimental design in thie chunk.

```{r pf}
data(mzrt)
# get the mean and rsd for each group
mzrtm <- enviGCMS::getdoe(mzrt)
gm <- mzrtm$groupmean
gr <- mzrtm$grouprsd
# find the blank group and pool QC group, demo data only have matrix blank
srm <- grepl('NIST',colnames(gm))
blk <- grepl('Matrix',colnames(gm))
# pqc <- grepl('pool',colnames(gm))
# filter by pool QC and blank's group mean intensity(pool QC should larger than three times of blank), return numbers and index
# in demo data, use sample average intensity for each peak
sum(indexmean <- apply(gm,1,function(x) all(x[srm]> 3*x[blk])))
# filter by pool qc rsd%, return numbers and index
# select rsd% cutoff 30
rsdcf <- 30
sum(indexrsd <- apply(gr,1,function(x) ifelse(is.na(x[srm]),T,x[srm]<rsdcf)))
# overlap with rsd% and mean filter
sum(index <- indexmean&indexrsd)

# new list, update group and remove pool qc/blk and save the new csv file
qcindex <- grepl('blank',mzrt$group$sample_group) | grepl('pool',mzrt$group$sample_group)
mzrtfilter <- enviGCMS::getfilter(mzrt,rowindex = index,colindex = !qcindex, name = 'lif')
```

# DDA MS/MS

```{r}
library(xcms)
dda_data <- MSnbase::readMSData(ddafile, mode = "onDisk")
cwp <- xcms::CentWaveParam(snthresh = 5, noise = 100, ppm = 10,
                     peakwidth = c(3, 30))
dda_data <- xcms::findChromPeaks(dda_data, param = cwp)
dda_spectra <- chromPeakSpectra(dda_data)
mz <- precursorMz(dda_spectra)
rt <- rtime(dda_spectra)
files <- fromFile(dda_spectra)
# check precursor ions
ex_mz <- 97.97
chromPeaks(dda_data, mz = ex_mz, ppm = 20)
ex_id <- rownames(chromPeaks(dda_data, mz = ex_mz, ppm = 20))
ex_spectra <- dda_spectra[mcols(dda_spectra)$peak_id %in% ex_id]
ex_spectrum <- combineSpectra(ex_spectra, method = consensusSpectrum, mzd = 0,
                              ppm = 20, minProp = 0.8, weighted = FALSE,
                              intensityFun = median, mzFun = median)
plot(ex_spectrum[[1]])
# output mgf
# MSnbase::writeMgfData(ex_spectrum,'dda.mgf')
```

# PMDDA analysis

## Generate MS/MS peaks list

Generate targeted list for MS/MS analysis from pmd analysis

```{r eval=F}
x <- pmd::globalstd(mzrtfilter,ng=NULL)

gettarget <- function(mz,rt,Drt=0.5,Dppm=20,ce=NA,name,n=NULL){
  head <-  c('On', 'Prec. m/z', 'Z','Ret. Time (min)', 'Delta Ret. Time (min)', 'Iso. Width', 'Collision Energy')
        rtn <- round(rt/60,3)
        temp = cbind('TRUE',mz,1,rtn,Drt,'Narrow (~1.3 m/z)',ce)
        data <- rbind(head,temp)
        colnames(data) <- c('TargetedMSMSTable',rep('',6))

        if(is.null(n)){
                name2 <- paste0(name,'.csv')
                utils::write.table(data,file = name2,row.names = F,col.names = F,sep=",")

        }else{
                idx <- targetsep(rt,Drt,n)
                for(i in 1:length(table(idx))){
                        namei <- paste0(name,i,'.csv')
                        idx2 <- idx == i
                        idx3 <- c(T,idx2)
                        datai <- data[idx3,]
                        utils::write.table(datai,file = namei,row.names = F,col.names = F,sep=",")
                }
        }

        return(data)
}

targetsep <- function(rt,Drt,n=6,seed=42){
        set.seed(seed)
        D <- Drt*60
        dis <- stats::dist(rt, method = "manhattan")
        fit <- stats::hclust(dis)
        inji <- rtcluster <- stats::cutree(fit, h = D)
        maxd <- max(table(rtcluster))
        m <- length(unique(rtcluster))
        inj <- ceiling(maxd/n)
        message(paste('You need',inj,'injections!'))
        for(i in c(1:m)) {
                z = 1:inj
                x <- rt[rtcluster==i]
                while(length(x) > inj & length(x)>n){
                        t <- sample(x,n)
                        w <- sample(z,1)
                        inji[rt %in% t] <- w
                        z <- z[!(z%in%w)]
                        x <- x[!(x %in% t)]
                }
                inji[rtcluster==i & rt %in% x] <- sample(z,sum(rtcluster==i & rt %in% x),replace = T)
        }
        return(inji)
}
zzz <- gettarget(x,n=6,Drt = 0.2,ce=20)
```

## Compare with other software

```{r}
# RAMclust
data(srmxset)
rcp <- RAMClustR::ramclustR(srmxset)
RC <- RAMClustR::do.findmain(rcp, mode = "positive", mzabs.error = 0.02, ppm.error = 10)
meanpeak <- apply(t(rcp$MSdata),1,mean)
df <-  cbind.data.frame(mz = rcp$fmz, rt = rcp$frt, cluster = rcp$featclus,meanpeak)
mol <- data.frame(mz = RC$M+1.0073,rt=RC$clrt)
write.csv(mol,'ramclust.csv')
rre <- read.csv('ramclust.csv')
#542
data(srmnxset)
rcp <- RAMClustR::ramclustR(srmnxset)
RC <- RAMClustR::do.findmain(rcp, mode = "negative", mzabs.error = 0.02, ppm.error = 10)
meanpeak <- apply(t(rcp$MSdata),1,mean)
dfn <-  cbind.data.frame(mz = rcp$fmz, rt = rcp$frt, cluster = rcp$featclus,meanpeak)
moln <- data.frame(mz = RC$M-1.0073,rt=RC$clrt)
write.csv(moln,'ramclustn.csv')
rren <- read.csv('ramclustn.csv')
# 770

# CAMERA
xsa <- CAMERA::annotate(srmxset, perfwhm=0.7, cor_eic_th=0.75,
ppm=10, polarity="positive")
peaklist <- CAMERA::getPeaklist(xsa)
peaklist$meanpeak <- apply(peaklist[,c(15:19)],1,mean)
length(unique(peaklist$pcgroup))
peaklist2 <- peaklist[index,]
length(unique(peaklist2$pcgroup))
write.csv(peaklist2,'camera.csv')
grouprt <- aggregate(peaklist$rt,by=list(peaklist$pcgroup), median)
grouprt$psgrp <- as.numeric(grouprt$Group.1)
grouprt2 <- merge(data.frame(xsa@annoGrp),grouprt,by='psgrp')
cre <- cbind.data.frame(mz=grouprt2$mass+1.0073,rt=grouprt2$x)
write.csv(cre,'cameratar.csv')
cre <- read.csv('cameratar.csv')
# 862

xsa <- CAMERA::annotate(srmnxset, perfwhm=0.7, cor_eic_th=0.75,
ppm=10, polarity="negative")
peaklistn <- CAMERA::getPeaklist(xsa)
peaklistn$meanpeak <- apply(peaklistn[,c(15:19)],1,mean)
length(unique(peaklistn$pcgroup))
peaklist2n <- peaklistn[indexn,]
length(unique(peaklist2n$pcgroup))
write.csv(peaklist2n,'cameran.csv')
grouprt <- aggregate(peaklistn$rt,by=list(peaklistn$pcgroup), median)
grouprt$psgrp <- as.numeric(grouprt$Group.1)
grouprt2 <- merge(data.frame(xsa@annoGrp),grouprt,by='psgrp')
cren <- cbind.data.frame(mz=grouprt2$mass-1.0073,rt=grouprt2$x)
write.csv(cren,'camerantar.csv')
cren <- read.csv('camerantar.csv')
# 710

# PMD
pos <- enviGCMS::getmzrtcsv('rppmzrt.csv')
neg <- enviGCMS::getmzrtcsv('rpnmzrt.csv')

pospmd <- pmd::globalstd(pos,sda=F,ng = NULL)
pospmd2 <- pmd::getcluster(pospmd,corcutoff = 0.9)
sum(pospmd2$stdmassindex2)
# 780
pre <- cbind.data.frame(mz=pospmd2$mz[pospmd2$stdmassindex2],rt=pospmd2$rt[pospmd2$stdmassindex2])
write.csv(pre,'pretar.csv')
pre <- read.csv('pretar.csv')

negpmd <- pmd::globalstd(neg,sda=F,ng = NULL)
negpmd2 <- pmd::getcluster(negpmd,corcutoff = 0.9)
sum(negpmd2$stdmassindex2)
pren <- cbind.data.frame(mz=negpmd2$mz[negpmd2$stdmassindex2],rt=negpmd2$rt[negpmd2$stdmassindex2])
write.csv(pren,'prentar.csv')
pren <- read.csv('prentar.csv')

# overlap
sum(paste(round(rre$mz,2),round(rre$rt,-1)) %in% paste(round(cre$mz,2),round(cre$rt,-1)))
sum(paste(round(pre$mz,2),round(pre$rt,-1)) %in% paste(round(cre$mz,2),round(cre$rt,-1)))
sum(paste(round(pre$mz,2),round(pre$rt,-1)) %in% paste(round(rre$mz,2),round(rre$rt,-1)))

rreidx <- paste(round(rre$mz,2),round(rre$rt,-1))
creidx <- paste(round(cre$mz,2),round(cre$rt,-1))
preidx <- paste(round(pre$mz,2),round(pre$rt,-1))

rrenidx <- paste(round(rren$mz,2),round(rren$rt,-1))
crenidx <- paste(round(cren$mz,2),round(cren$rt,-1))
prenidx <- paste(round(pren$mz,2),round(pren$rt,-1))

venn::venn(list(RamClustR=rreidx,CAMERA=creidx,PMD=preidx))
venn::venn(list(RamClustR=rrenidx,CAMERA=crenidx,PMD=prenidx))

rt <- gettarget(rre$mz,rre$rt,n=6,Drt = 0.2,ce=20,name = 'ramclustr')
ct <- gettarget(cre$mz,cre$rt,n=6,Drt = 0.2,ce=20,name = 'CAMERA')
pt <- gettarget(pre$mz,pre$rt,n=6,Drt = 0.2,ce=20,name = 'pmd')
rtn <- gettarget(rren$mz,rren$rt,n=6,Drt = 0.2,ce=20,name = 'ramclustrn')
ctn <- gettarget(cren$mz,cren$rt,n=6,Drt = 0.2,ce=20,name = 'CAMERAn')
ptn <- gettarget(pren$mz,pren$rt,n=6,Drt = 0.2,ce=20,name = 'pmdn')

# remove wrong mode annotation and duplicated annotation
posgnps <- read.csv('posnodeanno.csv')
neggnps <- read.csv('negnodeanno.csv')

library(eulerr)
num <- as.numeric(table(posgnps$DefaultGroups))
names(num) <- c('DDA','DDA&Matrix','DDA&Matrix&PMD&CAMERA','DDA&Matrix&PMD&CAMERA&RAMClustR','DDA&Matrix&CAMERA','DDA&Matrix&CAMERA&RAMClustR','DDA&Matrix&RAMClustR','DDA&PMD','DDA&PMD&CAMERA','DDA&PMD&CAMERA&RAMClustR','DDA&PMD&RAMClustR','DDA&CAMERA','DDA&CAMERA&RAMClustR','DDA&RAMClustR','Matrix','Matrix&CAMERA&RAMClustR','PMD','PMD&CAMERA','PMD&CAMERA&RAMClustR','PMD&RAMClustR','CAMERA','CAMERA&RAMClustR','RAMClustR')
fit1 <- euler(num)
png('comparepos.png',res=300,width = 2000,height = 2000)
plot(fit1,quantities = TRUE)
dev.off()

num <- as.numeric(table(neggnps$DefaultGroups))
names(num) <- c('Matrix','DDA&Matrix','DDA&Matrix&RAMClustR','DDA&Matrix&PMD&CAMERA&RAMClustR','DDA&Matrix&CAMERA&RAMClustR','DDA&Matrix&CAMERA','DDA','DDA&RAMClustR','DDA&PMD&RAMClustR','DDA&PMD&CAMERA&RAMClustR','DDA&PMD','DDA&CAMERA&PMD','DDA&CAMERA','RAMClustR','RAMClustR&PMD','PMD','PMD&CAMERA','CAMERA')
fit1 <- euler(num)
png('compareneg.png',res=300,width = 2000,height = 2000)
plot(fit1,quantities = TRUE)
dev.off()
```

## Extract mgf files

```{r eval=F}
# run the first download chunk to get the files path
library(xcms)
dda_data <- MSnbase::readMSData(pmddafile, mode = "onDisk")
cwp <- xcms::CentWaveParam(snthresh = 5, noise = 100, ppm = 10,
                     peakwidth = c(3, 30))
dda_data <- xcms::findChromPeaks(dda_data, param = cwp)
dda_spectra <- chromPeakSpectra(dda_data)
# get mgf for each compounds
ex_mz <- precursorMz(dda_spectra)
# check precursor ions
for(i in 1:length(ex_mz)){
  ex_id <- rownames(chromPeaks(dda_data, mz = ex_mz[i], ppm = 10))
  if(sum(mcols(dda_spectra)$peak_id %in% ex_id)!=0){
    ex_spectra <- dda_spectra[mcols(dda_spectra)$peak_id %in% ex_id]
    ex_spectrum <- combineSpectra(ex_spectra, method = consensusSpectrum, mzd = 0,
                              ppm = 10, minProp = 0.05, weighted = FALSE,
                              intensityFun = median, mzFun = median)
    name <- paste0('pmdda',i,'.mgf')
    writeMgfData(ex_spectrum,name)
  }
}
# compare with dda
dda_data <- MSnbase::readMSData(ddafile, mode = "onDisk")
cwp <- xcms::CentWaveParam(snthresh = 5, noise = 100, ppm = 10,
                     peakwidth = c(3, 30))
dda_data <- xcms::findChromPeaks(dda_data, param = cwp)
dda_spectra <- chromPeakSpectra(dda_data)
# get mgf for each compounds
data(mzrt)
range <- cbind.data.frame(mzrt$mzrange,mzrt$rtrange)
# check precursor ions
for(i in 1:nrow(range)){
  ex_id <- rownames(chromPeaks(dda_data, mz = range[i,c("mzmin", "mzmax" )],rt=range[i,c("rtmin", "rtmax")], ppm = 10))
  if(sum(mcols(dda_spectra)$peak_id %in% ex_id)!=0){
    ex_spectra <- dda_spectra[mcols(dda_spectra)$peak_id %in% ex_id]
    ex_spectrum <- combineSpectra(ex_spectra, method = consensusSpectrum, mzd = 0,
                              ppm = 10, minProp = 0.05, weighted = FALSE,
                              intensityFun = median, mzFun = median)
    name <- paste0('dda',i,'.mgf')
    writeMgfData(ex_spectrum,name)
  }
}
## upload here
## https://gnps.ucsd.edu/
```

# Formula assign

```{r}
data(mzrt)
library(Rdisop)
# isotop group formula assign
p1 <- pmd::getpaired(mzrt)
pi <- enviGCMS::getfilter(mzrt,rowindex = p1$isoindex)
rtg <- p1$rtcluster[p1$isoindex]
iso <- p1$iso
formula <- list()
for (i in 1:length(unique(iso$rtg))){
  isoi <- iso[iso$rtg == unique(iso$rtg)[i],]
  insi <- rowSums(pi$data[rtg==unique(iso$rtg)[i],],na.rm = T)
  mzi <- round(pi$mz[rtg==unique(iso$rtg)[i]],4) 
  net <- igraph::graph_from_data_frame(isoi,directed = F)
  group <- igraph::groups(igraph::components(net))
  groupi <- list()
  for (j in 1:length(group)) {
    mz <- round(as.numeric(group[[j]]),4)
    inst <- insi[mzi%in%mz]
    molecules <- decomposeIsotopes(masses = mz, intensities = inst,elements = initializeElements(c("C","H","N","O","P")))
    if(!is.null(molecules)){
      Formula <- getFormula(molecules)
      Formulav <- Formula[getValid(molecules)=='Valid']
      groupi[[j]] <- Formulav
    }
  }
  formula[[i]] <- groupi
}

# mass formula assign
p2 <- pmd::getstd(p1)
mass <- p2$mz[p2$stdmassindex]
massf <- list()
for(i in 1:sum(p2$stdmassindex)){
  molecules <- decomposeMass(mass = mass[i],elements = initializeElements(c("C","H","N","O","P")))
  if(!is.null(molecules)){
      Formula <- getFormula(molecules)
      Formulav <- Formula[getValid(molecules)=='Valid']
      massf[[i]] <- Formulav
    }
}

```

# MS/MS Local Annotation

Use HMDB MS/MS database to annotate compounds.

```{r}
data("qtof")
# this is the sepctra of HMDB0034004
file <- system.file("extdata", "challenge-msms.mgf", package = "rmwf")
# dot product similarity
anno1 <- enviGCMS::dotpanno(file,db = qtof)
unique(anno1$name)
# X rank algorithm
anno2 <- enviGCMS::xrankanno(file,db = qtof)
unique(anno2$name)
# pmd msms annotation
anno3 <- pmd::pmdanno(file,db=qtof)
unique(anno3$name)
enviGCMS::plotanno(anno3)
```
